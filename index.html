<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Emotion Score Generator (Blokken-style)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 24px; }
    .wrap { display: grid; grid-template-columns: 380px 1fr; gap: 16px; align-items: start; }
    textarea { width: 100%; height: 220px; padding: 10px; font-size: 14px; }
    button { padding: 10px 12px; font-size: 14px; cursor: pointer; }
    .row { display:flex; gap:8px; flex-wrap:wrap; margin-top:10px; }
    .hint { font-size: 12px; color:#333; line-height: 1.6; margin-top:10px; }
    canvas { width: 100%; max-width: 1200px; border: 1px solid #ddd; background:#fff; }
    .legend { display:flex; flex-wrap:wrap; gap:10px; margin-top:12px; }
    .swatch { display:flex; align-items:center; gap:6px; font-size:12px; }
    .box { width:14px; height:14px; border:1px solid #0002; }
    .pill { display:inline-block; padding:2px 8px; border-radius:999px; background:#f3f3f3; font-size:12px; margin-right:6px;}
  </style>
</head>
<body>
  <h1 style="margin:0 0 10px 0;">Emotion X-ray → Graphic Score Generator</h1>

  <div class="wrap">
    <div>
      <textarea id="input">I love this app but it crashes now</textarea>

      <div class="row">
        <button id="btnGen">Generate</button>
        <button id="btnDownload">Download PNG</button>
        <button id="btnRandomize">Randomize seed</button>
      </div>

      <div class="hint">
        <div><span class="pill">한 문장</span> 한 문장은 “하나의 연결선” 위에 끊긴 블록들이 얹히는 구조</div>
      </div>

      <div class="legend" id="legend"></div>
    </div>

    <div>
      <canvas id="c" width="1600" height="980"></canvas>
    </div>
  </div>

<script>
(() => {
  const COLORS = {
    basic_pos:   "#00FF90",
    strong_pos:  "#DFFF29",
    attach_pos:  "#FF6134",
    extreme_pos: "#F7399D",
    mild_neg:    "#00FFFF",
    strong_neg:  "#006AA0",
    extreme_neg: "#020605",
  };

  // Legend
  const legendEl = document.getElementById("legend");
  [
    ["기본 긍정", COLORS.basic_pos],
    ["강화 긍정", COLORS.strong_pos],
    ["감정 애착", COLORS.attach_pos],
    ["극단 긍정", COLORS.extreme_pos],
    ["약한 불만", COLORS.mild_neg],
    ["강한 불만", COLORS.strong_neg],
    ["극단 부정", COLORS.extreme_neg],
  ].forEach(([name, hex]) => {
    const d = document.createElement("div");
    d.className = "swatch";
    d.innerHTML = `<span class="box" style="background:${hex}"></span>${name} (${hex})`;
    legendEl.appendChild(d);
  });

  const KW = {
    basic_pos: new Set(["good","nice","helpful","useful","easy","simple","convenient","cool","fun","works","reliable","smooth","accurate","decent","fine","okay"]),
    strong_pos: new Set(["great","excellent","fantastic","wonderful","impressed","powerful","brilliant","outstanding","productive","valuable","amazing"]),
    attach_pos: new Set(["love","loved","loving","favorite","favourite","obsessed","addicted","bestie","sister","everything","blessing","grateful","indispensable"]),
    extreme_pos: new Set(["best","perfect","10/10","five","stars","must-have","life-changing","beyond","mind","blowing","goat"]),
    mild_neg: new Set(["slow","laggy","buggy","glitchy","glitch","annoying","confusing","frustrating","limited","not","working","issue","problem","crash","crashes","freeze","freezes","stutter","stutters"]),
    strong_neg: new Set(["bad","terrible","horrible","ridiculous","unacceptable","useless","waste","misleading","unfair","overpriced","greedy","broken"]),
    extreme_neg: new Set(["worst","scam","scammers","fraud","toxic","disgusting","trash","junk","poison","delete","uninstall","bye","done","never","again"]),
  };

  const TRIG = {
    type2_contrast: new Set(["but","however","though","although","yet"]),
    type3_time: new Set(["now","still","again","anymore","since","lately","recently","today","yesterday","already"]),
    type4_break: new Set(["delete","uninstall","bye","done"]),
  };

  const BASE_PITCH = {
    basic_pos: 0.30, strong_pos: 0.48, attach_pos: 0.62, extreme_pos: 0.86,
    mild_neg: 0.34, strong_neg: 0.66, extreme_neg: 0.94,
  };

  function splitSentences(text) {
    // ✅ “한 문장=한 줄” 원하면 아래처럼 '줄바꿈' 기준만으로도 가능.
    // 지금은 마침표로도 나뉘게 되어있으니, 원하면 아래 한 줄로 바꿔도 됨:
    // return (text || "").split(/[\n\r]+/g).map(s=>s.trim()).filter(Boolean);

    return (text || "")
      .split(/[\n\r]+|(?<=[.!?])\s+/g)
      .map(s => s.trim())
      .filter(Boolean);
  }

  function tokenize(sentence) {
    return sentence.trim().split(/\s+/g)
      .map(t => t.replace(/[^\w'\/-]/g, ""))
      .filter(Boolean);
  }

  function hasNeverAgain(tokensLower, i) {
    return (tokensLower[i] === "never" && tokensLower[i+1] === "again");
  }

  let seed = 1234567;
  function rand() {
    seed = (seed * 1664525 + 1013904223) % 4294967296;
    return seed / 4294967296;
  }
  function randRange(a,b){ return a + (b-a)*rand(); }

  function scoreHits(tokens) {
    const hits = {
      basic_pos: 0, strong_pos: 0, attach_pos: 0, extreme_pos: 0,
      mild_neg: 0, strong_neg: 0, extreme_neg: 0,
    };
    for (const raw of tokens) {
      const t = raw.toLowerCase();
      for (const k in KW) if (KW[k].has(t)) hits[k] += 1;
      if (t === "10/10") hits.extreme_pos += 2;
    }
    return hits;
  }

  function pickCategory(tokens) {
    const hits = scoreHits(tokens);
    let bestK = "basic_pos", bestV = -1;
    for (const k in hits) {
      if (hits[k] > bestV) { bestV = hits[k]; bestK = k; }
    }
    if (bestV <= 0) return { key:"basic_pos", hex: COLORS.basic_pos, hitCount: 0 };
    return { key: bestK, hex: COLORS[bestK], hitCount: bestV };
  }

  function intensityFromTokens(tokens) {
    const hits = scoreHits(tokens);
    const sumHits = Object.values(hits).reduce((a,b)=>a+b,0);
    const lenBoost = Math.min(3, Math.floor(tokens.length / 6));
    const base = sumHits * 2 + lenBoost;
    return Math.max(0, Math.min(10, base));
  }

  function thicknessFromIntensity(intensity) {
    return 2 + (intensity / 10) * 22;
  }
  function opacityFromIntensity(intensity) {
    return Math.min(0.96, 0.22 + (intensity/10)*0.70);
  }

  function initialType(tokensLower) {
    const first = tokensLower[0];
    if (first === "i" || first === "i'm" || first === "im" || first === "my") return 1;
    return 1;
  }

  function nextType(tokensLower, i, curType) {
    if (hasNeverAgain(tokensLower, i)) return 4;
    const t = tokensLower[i];
    if (TRIG.type4_break.has(t)) return 4;
    if (TRIG.type3_time.has(t)) return 3;
    if (TRIG.type2_contrast.has(t)) return 2;
    return curType;
  }

  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  function clearCanvas() {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0,0,canvas.width,canvas.height);
  }

  function drawStaff(yTop, staffH, lines=3) {
    ctx.save();
    ctx.strokeStyle = "rgba(0,0,0,0.18)";
    ctx.lineWidth = 1;
    for (let i=0; i<=lines; i++) {
      const y = yTop + (staffH * i/lines);
      ctx.beginPath();
      ctx.moveTo(50, y);
      ctx.lineTo(canvas.width - 50, y);
      ctx.stroke();
    }
    ctx.restore();
  }

  function yFromPitch(pitch01, yTop, staffH) {
    return yTop + (1 - pitch01) * staffH;
  }

  // ✅ NEW: 연결선(한 문장 = 하나의 흐름)
  function drawContinuityLine(xStart, xEnd, y, colorHex) {
    ctx.save();
    ctx.strokeStyle = colorHex;         // 감정색으로 연결선
    ctx.globalAlpha = 0.25;            // 너무 세지 않게
    ctx.lineWidth = 2;                 // 얇게
    ctx.beginPath();
    ctx.moveTo(xStart, y);
    ctx.lineTo(xEnd, y);
    ctx.stroke();
    ctx.restore();
  }

  function drawSentence(sentence, yTop, staffH) {
    const tokens = tokenize(sentence);
    const tokensLower = tokens.map(t => t.toLowerCase());
    if (!tokens.length) return;

    const xStart = 70;
    const xEnd = canvas.width - 70;
    const usableW = xEnd - xStart;

    // 문장 전체 카테고리(연결선 색용)
    const overallCat = pickCategory(tokens);
    let overallPitch = (BASE_PITCH[overallCat.key] ?? 0.4) + randRange(-0.02, 0.02);
    overallPitch = Math.max(0.05, Math.min(0.98, overallPitch));
    const yBase = yFromPitch(overallPitch, yTop, staffH);

    // ✅ 연결선 먼저 그리기 (한 문장 흐름)
    drawContinuityLine(xStart, xEnd, yBase, overallCat.hex);

    // time mapping weights
    const weights = tokens.map(t => Math.max(1.0, Math.min(10, t.length / 3)));
    const totalW = weights.reduce((a,b)=>a+b,0);
    let x = xStart;

    let curType = initialType(tokensLower);
    let runTokens = [];
    let runType = curType;

    function flushRun(runWeight) {
      if (!runTokens.length) return { stop:false, usedW: 0 };

      const cat = pickCategory(runTokens);
      const intensity = intensityFromTokens(runTokens);
      const thick = thicknessFromIntensity(intensity);
      const alpha = opacityFromIntensity(intensity);

      // run width
      const runW = usableW * (runWeight / totalW);

      // pitch per run: base from category, but still “attached” to sentence baseline
      let pitch = (BASE_PITCH[cat.key] ?? 0.4);
      if (runType === 2) pitch -= 0.06;
      if (runType === 3) pitch += 0.02;
      if (runType === 4) pitch += 0.10;
      pitch = Math.max(0.05, Math.min(0.98, pitch + randRange(-0.03, 0.03)));
      const y = yFromPitch(pitch, yTop, staffH);

      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = cat.hex;

      if (runType === 4) {
        const W = Math.min(usableW * 0.35, Math.max(140, runW + 180));
        const H = Math.min(staffH * 0.70, Math.max(46, thick * 3.0));
        ctx.fillRect(x, y - H/2, W, H);
        ctx.restore();
        return { stop:true, usedW: runW };
      }

      if (runType === 3) {
        const dotN = Math.max(6, Math.floor(runW / 24));
        const size = Math.max(6, Math.min(18, thick * 0.7));
        for (let i=0; i<dotN; i++) {
          const dx = x + i * (runW / dotN) + randRange(-4, 4);
          // dot y는 baseline 근처로 오게 약간만 흔들기
          const dy = yBase + randRange(-10, 10);
          ctx.fillRect(dx, dy - size/2, size, size);
        }
        ctx.restore();
        return { stop:false, usedW: runW };
      }

      // TYPE1 / TYPE2 fragment blocks
      const fragBase = (runType === 1) ? 3 : 6;
      const fragN = Math.max(2, Math.min(10, fragBase + Math.floor(runTokens.length/3)));

      let remaining = runW;
      let xx = x;

      for (let i=0; i<fragN; i++) {
        const minW = (runType === 1) ? 30 : 18;
        const maxW = (runType === 1) ? 140 : 90;
        const w = Math.min(remaining, randRange(minW, maxW));
        const h = Math.max(8, Math.min(staffH * 0.55, thick * randRange(1.2, 2.4)));

        // fragment는 baseline에 더 붙여서 “하나의 문장” 느낌 강화
        const dy = (runType === 2) ? randRange(-14, 14) : randRange(-10, 10);
        ctx.fillRect(xx, (yBase + dy) - h/2, w, h);

        const gap = (runType === 1) ? randRange(10, 22) : randRange(18, 46);
        xx += w + gap;
        remaining -= (w + gap);
        if (remaining < 10) break;
      }

      ctx.restore();
      return { stop:false, usedW: runW };
    }

    // scan tokens, accumulate run weight
    let runWeight = 0;

    for (let i=0; i<tokens.length; i++) {
      const w = weights[i];
      const nt = nextType(tokensLower, i, curType);

      if (nt !== curType) {
        const res = flushRun(runWeight);
        if (res.stop) return;
        x += res.usedW + ((curType === 2) ? 22 : 16);
        curType = nt;
        runType = curType;
        runTokens = [];
        runWeight = 0;
      }

      runTokens.push(tokens[i]);
      runWeight += w;

      if (curType === 4) {
        if (hasNeverAgain(tokensLower, i) && i+1 < tokens.length) {
          runTokens.push(tokens[i+1]);
          runWeight += weights[i+1];
        }
        flushRun(runWeight);
        return;
      }

      if (hasNeverAgain(tokensLower, i)) i++;
    }

    const last = flushRun(runWeight);
    x += last.usedW;
  }

  function draw(text) {
    clearCanvas();

    // Header
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.85)";
    ctx.font = "600 28px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText("Emotion Score", 70, 54);
    ctx.restore();

    const sentences = splitSentences(text);

    // ✅ 라벨은 “한 번만” 표시 (여러 줄이어도 중복 X)
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.55)";
    ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText("highest tone", 70, 92);
    ctx.fillText("lowest tone", 70, 92 + 120 + 16); // 첫 staff 기준 위치(보기용)
    ctx.restore();

    const marginTop = 110;
    const gap = 34;
    const staffH = 120;

    let y = marginTop;

    for (let s=0; s<sentences.length; s++) {
      if (y + staffH > canvas.height - 60) break;
      drawStaff(y, staffH, 3);
      drawSentence(sentences[s], y, staffH);
      y += staffH + gap;
    }
  }

  // UI
  const inputEl = document.getElementById("input");
  document.getElementById("btnGen").addEventListener("click", () => draw(inputEl.value));
  document.getElementById("btnDownload").addEventListener("click", () => {
    const a = document.createElement("a");
    a.href = canvas.toDataURL("image/png");
    a.download = "emotion-score.png";
    a.click();
  });
  document.getElementById("btnRandomize").addEventListener("click", () => {
    seed = Math.floor(Math.random() * 1e9);
    draw(inputEl.value);
  });

  draw(inputEl.value);
})();
</script>
</body>
</html>
