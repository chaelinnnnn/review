<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Emotion Score Generator (Blokken-style)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 24px; }
    .wrap { display: grid; grid-template-columns: 380px 1fr; gap: 16px; align-items: start; }
    textarea { width: 100%; height: 220px; padding: 10px; font-size: 14px; }
    button { padding: 10px 12px; font-size: 14px; cursor: pointer; }
    .row { display:flex; gap:8px; flex-wrap:wrap; margin-top:10px; }
    .hint { font-size: 12px; color:#333; line-height: 1.6; margin-top:10px; }
    canvas { width: 100%; max-width: 1200px; border: 1px solid #ddd; background:#fff; }
    .legend { display:flex; flex-wrap:wrap; gap:10px; margin-top:12px; }
    .swatch { display:flex; align-items:center; gap:6px; font-size:12px; }
    .box { width:14px; height:14px; border:1px solid #0002; }
    .pill { display:inline-block; padding:2px 8px; border-radius:999px; background:#f3f3f3; font-size:12px; margin-right:6px;}
  </style>
</head>
<body>
  <h1 style="margin:0 0 10px 0;">Emotion X-ray → Graphic Score Generator</h1>

  <div class="wrap">
    <div>
      <textarea id="input">I love this app but it crashes now. I paid for premium and still see ads. Never again, I'm done.</textarea>

      <div class="row">
        <button id="btnGen">Generate</button>
        <button id="btnDownload">Download PNG</button>
        <button id="btnRandomize">Randomize seed</button>
      </div>

      <div class="hint">
        <div><span class="pill">Color</span> 감정 카테고리(너의 HEX) → 세그먼트 색</div>
        <div><span class="pill">Pitch</span> 감정의 “각성도” → 세로 위치(높을수록 위)</div>
        <div><span class="pill">Volume</span> 감정 강도 → 세그먼트 두께/면적</div>
        <div><span class="pill">Form</span> 문장 신호에 따라 TYPE 전환(끊긴 블록)</div>
        <div style="margin-top:8px;">
          <b>TYPE 전환 규칙</b><br/>
          • TYPE1: 기본 진행<br/>
          • TYPE2: 접속사(but/however/though/although/yet) 등장 이후<br/>
          • TYPE3: 시간표현(now/still/again/anymore/since/lately/recently/already) 등장 이후<br/>
          • TYPE4: 단절(delete/uninstall/bye/done/never again) 등장 이후 → 큰 종결 블록 + 종료
        </div>
      </div>

      <div class="legend" id="legend"></div>
    </div>

    <div>
      <canvas id="c" width="1600" height="980"></canvas>
    </div>
  </div>

<script>
(() => {
  // =========================
  // 1) USER COLOR PALETTE (fixed)
  // =========================
  const COLORS = {
    basic_pos:   "#00FF90", // 기본 긍정
    strong_pos:  "#DFFF29", // 강화 긍정
    attach_pos:  "#FF6134", // 감정 애착
    extreme_pos: "#F7399D", // 극단 긍정
    mild_neg:    "#00FFFF", // 약한 불만
    strong_neg:  "#006AA0", // 강한 불만
    extreme_neg: "#020605", // 극단 부정
  };

  // Legend UI
  const legendEl = document.getElementById("legend");
  [
    ["기본 긍정", COLORS.basic_pos],
    ["강화 긍정", COLORS.strong_pos],
    ["감정 애착", COLORS.attach_pos],
    ["극단 긍정", COLORS.extreme_pos],
    ["약한 불만", COLORS.mild_neg],
    ["강한 불만", COLORS.strong_neg],
    ["극단 부정", COLORS.extreme_neg],
  ].forEach(([name, hex]) => {
    const d = document.createElement("div");
    d.className = "swatch";
    d.innerHTML = `<span class="box" style="background:${hex}"></span>${name} (${hex})`;
    legendEl.appendChild(d);
  });

  // =========================
  // 2) KEYWORDS for COLOR CLASSIFICATION
  //    (extend anytime; this is just a starter set)
  // =========================
  const KW = {
    basic_pos: new Set(["good","nice","helpful","useful","easy","simple","convenient","cool","fun","works","reliable","smooth","accurate","decent","fine","okay"]),
    strong_pos: new Set(["great","excellent","fantastic","wonderful","impressed","powerful","brilliant","outstanding","productive","valuable","amazing"]),
    attach_pos: new Set(["love","loved","loving","favorite","favourite","obsessed","addicted","bestie","sister","everything","blessing","grateful","indispensable"]),
    extreme_pos: new Set(["best","perfect","10/10","five","stars","must-have","life-changing","beyond","mind","blowing","goat"]),

    mild_neg: new Set(["slow","laggy","buggy","glitchy","glitch","annoying","confusing","frustrating","limited","not","working","issue","problem","crash","crashes","freeze","freezes","stutter","stutters"]),
    strong_neg: new Set(["bad","terrible","horrible","ridiculous","unacceptable","useless","waste","misleading","unfair","overpriced","greedy","broken"]),
    extreme_neg: new Set(["worst","scam","scammers","fraud","toxic","disgusting","trash","junk","poison","delete","uninstall","bye","done","never","again"]),
  };

  // =========================
  // 3) SHAPE TRIGGERS (TYPE switches)
  // =========================
  const TRIG = {
    type2_contrast: new Set(["but","however","though","although","yet"]),
    type3_time: new Set(["now","still","again","anymore","since","lately","recently","today","yesterday","already"]),
    type4_break: new Set(["delete","uninstall","bye","done"]),
  };

  // =========================
  // 4) PITCH MAP (0..1)  higher = higher on staff
  //    - Treat as "arousal/activation" rather than literal musical pitch
  // =========================
  const BASE_PITCH = {
    basic_pos: 0.30,
    strong_pos: 0.48,
    attach_pos: 0.62,
    extreme_pos: 0.86,
    mild_neg: 0.34,
    strong_neg: 0.66,
    extreme_neg: 0.94,
  };

  // =========================
  // 5) TOKENIZE + SENTENCE SPLIT
  // =========================
  function splitSentences(text) {
    // Keep it simple: split by . ! ? or line breaks
    return (text || "")
      .split(/[\n\r]+|(?<=[.!?])\s+/g)
      .map(s => s.trim())
      .filter(Boolean);
  }

  function tokenize(sentence) {
    return sentence
      .trim()
      .split(/\s+/g)
      .map(t => t.replace(/[^\w'\/-]/g, "")) // strip punctuation but keep wordish chars
      .filter(Boolean);
  }

  function hasNeverAgain(tokensLower, i) {
    return (tokensLower[i] === "never" && tokensLower[i+1] === "again");
  }

  // =========================
  // 6) DETERMINISTIC RNG
  // =========================
  let seed = 1234567;
  function rand() {
    seed = (seed * 1664525 + 1013904223) % 4294967296;
    return seed / 4294967296;
  }
  function randRange(a,b){ return a + (b-a)*rand(); }

  // =========================
  // 7) COLOR PICK + INTENSITY
  // =========================
  function scoreHits(tokens) {
    const hits = {
      basic_pos: 0, strong_pos: 0, attach_pos: 0, extreme_pos: 0,
      mild_neg: 0, strong_neg: 0, extreme_neg: 0,
    };
    for (const raw of tokens) {
      const t = raw.toLowerCase();
      for (const k in KW) if (KW[k].has(t)) hits[k] += 1;
      if (t === "10/10") hits.extreme_pos += 2;
    }
    return hits;
  }

  function pickCategory(tokens) {
    const hits = scoreHits(tokens);
    let bestK = "basic_pos", bestV = -1;
    for (const k in hits) {
      if (hits[k] > bestV) { bestV = hits[k]; bestK = k; }
    }
    if (bestV <= 0) return { key:"basic_pos", hex: COLORS.basic_pos, hitCount: 0 };
    return { key: bestK, hex: COLORS[bestK], hitCount: bestV };
  }

  function intensityFromTokens(tokens) {
    // 0..10 : based on keyword hits + sentence length a bit
    const hits = scoreHits(tokens);
    const sumHits = Object.values(hits).reduce((a,b)=>a+b,0);
    const lenBoost = Math.min(3, Math.floor(tokens.length / 6)); // long talk feels stronger
    const base = sumHits * 2 + lenBoost; // simple
    return Math.max(0, Math.min(10, base));
  }

  function thicknessFromIntensity(intensity) {
    // volume -> thickness (px)
    return 2 + (intensity / 10) * 22; // 2..24
  }

  function opacityFromIntensity(intensity) {
    return Math.min(0.96, 0.22 + (intensity/10)*0.70);
  }

  // =========================
  // 8) TYPE SCAN (progressive switching)
  // =========================
  function initialType(tokensLower) {
    const first = tokensLower[0];
    if (first === "i" || first === "i'm" || first === "im" || first === "my") return 1;
    return 1; // default start
  }

  function nextType(tokensLower, i, curType) {
    if (hasNeverAgain(tokensLower, i)) return 4;
    const t = tokensLower[i];

    if (TRIG.type4_break.has(t)) return 4;
    if (TRIG.type3_time.has(t)) return 3;
    if (TRIG.type2_contrast.has(t)) return 2;

    return curType;
  }

  // =========================
  // 9) DRAW: BLOKKEN-LIKE SCORE
  // =========================
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  function clearCanvas() {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0,0,canvas.width,canvas.height);
  }

  function drawStaff(yTop, staffH, lines=3) {
    ctx.save();
    ctx.strokeStyle = "rgba(0,0,0,0.20)";
    ctx.lineWidth = 1;
    for (let i=0; i<=lines; i++) {
      const y = yTop + (staffH * i/lines);
      ctx.beginPath();
      ctx.moveTo(50, y);
      ctx.lineTo(canvas.width - 50, y);
      ctx.stroke();
    }
    ctx.restore();
  }

  function yFromPitch(pitch01, yTop, staffH) {
    // higher pitch => closer to yTop
    return yTop + (1 - pitch01) * staffH;
  }

  // Core: render one sentence as multiple "runs"
  function drawSentence(sentence, yTop, staffH) {
    const tokens = tokenize(sentence);
    const tokensLower = tokens.map(t => t.toLowerCase());
    if (!tokens.length) return;

    // progressive run segmentation by TYPE
    let curType = initialType(tokensLower);
    let runTokens = [];
    let runType = curType;

    // layout params
    const xStart = 70;
    const xEnd = canvas.width - 70;
    const usableW = xEnd - xStart;

    // time mapping: each token consumes width proportional to its character length
    const weights = tokens.map(t => Math.max(1.0, Math.min(10, t.length / 3)));
    const totalW = weights.reduce((a,b)=>a+b,0);

    let x = xStart;

    function flushRun() {
      if (!runTokens.length) return { stop:false };

      // color + pitch + volume for this run
      const cat = pickCategory(runTokens);
      const intensity = intensityFromTokens(runTokens);
      const thick = thicknessFromIntensity(intensity);
      const alpha = opacityFromIntensity(intensity);

      // pitch: category base + small jitter + type influence
      let pitch = BASE_PITCH[cat.key] ?? 0.4;
      // TYPE influence: 2 = slight drop (hesitation), 3 = repeated (stable band), 4 = spike (final)
      if (runType === 2) pitch -= 0.08;
      if (runType === 3) pitch += 0.02;
      if (runType === 4) pitch += 0.10;
      pitch = Math.max(0.05, Math.min(0.98, pitch + randRange(-0.03, 0.03)));

      const y = yFromPitch(pitch, yTop, staffH);

      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = cat.hex;

      // compute run width from its token weights
      let runWeight = 0;
      for (const rt of runTokens) {
        const idx = tokens.indexOf(rt); // not perfect for duplicates; ok for visuals
      }
      // better: sum by char length directly
      runWeight = runTokens.reduce((a,t)=>a+Math.max(1.0, Math.min(10, t.length/3)), 0);
      const runW = usableW * (runWeight / totalW);

      // BLOKKEN STYLE:
      // - TYPE1: few medium rectangles, slight gaps (stable)
      // - TYPE2: more fragments + bigger gaps (broken)
      // - TYPE3: dotted squares (repetition)
      // - TYPE4: one large terminal block and stop

      if (runType === 4) {
        // terminal block: big, dense
        const W = Math.min(usableW * 0.35, Math.max(120, runW + 160));
        const H = Math.min(staffH * 0.70, Math.max(40, thick * 3.0));
        ctx.fillRect(x, y - H/2, W, H);
        ctx.restore();
        return { stop:true };
      }

      if (runType === 3) {
        // dotted: small squares along run
        const dotN = Math.max(6, Math.floor(runW / 24));
        const size = Math.max(6, Math.min(18, thick * 0.7));
        for (let i=0; i<dotN; i++) {
          const dx = x + i * (runW / dotN) + randRange(-4, 4);
          const dy = y + randRange(-10, 10);
          ctx.fillRect(dx, dy - size/2, size, size);
        }
        x += runW + 14;
        ctx.restore();
        return { stop:false };
      }

      // TYPE1 or TYPE2: fragment blocks
      const fragBase = (runType === 1) ? 3 : 6; // more pieces when broken
      const fragN = Math.max(2, Math.min(10, fragBase + Math.floor(runTokens.length/3)));

      let remaining = runW;
      let xx = x;

      for (let i=0; i<fragN; i++) {
        const minW = (runType === 1) ? 30 : 18;
        const maxW = (runType === 1) ? 140 : 90;
        const w = Math.min(remaining, randRange(minW, maxW));
        const h = Math.max(8, Math.min(staffH * 0.55, thick * randRange(1.2, 2.4)));

        // slight vertical jitter
        const dy = randRange(-12, 12);

        ctx.fillRect(xx, (y + dy) - h/2, w, h);

        const gap = (runType === 1) ? randRange(10, 22) : randRange(18, 46); // bigger gaps for broken
        xx += w + gap;
        remaining -= (w + gap);
        if (remaining < 10) break;
      }

      x += runW + ((runType === 1) ? 16 : 22);
      ctx.restore();
      return { stop:false };
    }

    // scan + build runs
    for (let i=0; i<tokens.length; i++) {
      const nt = nextType(tokensLower, i, curType);

      if (nt !== curType) {
        const res = flushRun();
        if (res.stop) return;
        curType = nt;
        runType = curType;
        runTokens = [];
      }

      runTokens.push(tokens[i]);

      // if Type4 triggered, flush immediately to stop
      if (curType === 4) {
        // include "again" if it was "never again"
        if (hasNeverAgain(tokensLower, i) && i+1 < tokens.length) runTokens.push(tokens[i+1]);
        flushRun();
        return;
      }

      // skip the second word of "never again" bigram to avoid double handling
      if (hasNeverAgain(tokensLower, i)) i++;
    }

    flushRun();
  }

  function draw(text) {
    clearCanvas();

    // Title-like header (optional)
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.85)";
    ctx.font = "600 28px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText("Emotion Score", 70, 54);
    ctx.restore();

    // labels highest/lowest tone
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.55)";
    ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText("highest tone", 70, 90);
    ctx.fillText("lowest tone", 70, 0); // will place per staff below
    ctx.restore();

    const sentences = splitSentences(text);
    const marginTop = 110;
    const gap = 34;
    const staffH = 120;

    let y = marginTop;

    for (let s=0; s<sentences.length; s++) {
      if (y + staffH > canvas.height - 60) break;

      drawStaff(y, staffH, 3);

      // lowest tone label per staff
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText("lowest tone", 70, y + staffH + 16);
      ctx.restore();

      drawSentence(sentences[s], y, staffH);

      y += staffH + gap;
    }
  }

  // =========================
  // 10) UI handlers
  // =========================
  const inputEl = document.getElementById("input");
  document.getElementById("btnGen").addEventListener("click", () => draw(inputEl.value));

  document.getElementById("btnDownload").addEventListener("click", () => {
    const a = document.createElement("a");
    a.href = canvas.toDataURL("image/png");
    a.download = "emotion-score.png";
    a.click();
  });

  document.getElementById("btnRandomize").addEventListener("click", () => {
    seed = Math.floor(Math.random() * 1e9);
    draw(inputEl.value);
  });

  // first render
  draw(inputEl.value);
})();
</script>
</body>
</html>
