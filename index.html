<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Emotion Grid Visualizer</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@300;400&display=swap');
  *{box-sizing:border-box;margin:0;padding:0;}
  body{
    background:#fff;
    font-family:'IBM Plex Mono',monospace;
    font-size:10px;color:#000;
    display:flex;flex-direction:column;min-height:100vh;
  }

  /* ── TOPBAR ── */
  .topbar{
    display:flex;align-items:baseline;justify-content:space-between;
    padding:14px 28px 10px;
    border-bottom:1px solid #000;
  }
  .logo{
    font-size:9px;letter-spacing:.22em;text-transform:uppercase;
  }
  .right{display:flex;gap:0;}
  .btn{
    background:none;border:none;border-left:1px solid #000;
    padding:0 16px;height:28px;
    font-family:'IBM Plex Mono',monospace;
    font-size:9px;letter-spacing:.18em;text-transform:uppercase;
    color:#000;cursor:pointer;
  }
  .btn:first-child{border-left:none;}
  .btn:hover{background:#000;color:#fff;}

  /* ── LAYOUT: two column ── */
  .layout{display:flex;flex:1;min-height:0;}

  /* left sidebar */
  .panel{
    width:240px;min-width:240px;
    border-right:1px solid #000;
    display:flex;flex-direction:column;
    background:#fff;overflow-y:auto;
  }

  .panel-section{
    padding:16px 20px;
    border-bottom:1px solid #000;
  }
  .panel-section:last-child{border-bottom:none;}

  .plabel{
    font-size:8px;letter-spacing:.22em;text-transform:uppercase;
    color:#000;opacity:.45;
    margin-bottom:10px;
  }

  textarea{
    width:100%;height:100px;resize:none;padding:10px;
    font-family:'IBM Plex Mono',monospace;font-size:10px;line-height:1.7;
    background:#f8f8f8;border:1px solid #000;outline:none;color:#000;
    border-radius:0;
  }
  .brow{display:flex;margin-top:8px;border:1px solid #000;}
  .bprim{
    flex:2;background:#000;color:#fff;border:none;border-right:1px solid #fff;
    padding:9px 0;
    font-family:'IBM Plex Mono',monospace;font-size:8px;letter-spacing:.18em;
    text-transform:uppercase;cursor:pointer;
  }
  .bprim:hover{background:#333;}
  .bsec{
    flex:1;background:#fff;border:none;
    padding:9px 0;
    font-family:'IBM Plex Mono',monospace;font-size:11px;
    color:#000;cursor:pointer;text-align:center;
  }
  .bsec:hover{background:#f0f0f0;}

  /* legend rows — key:value style like reference */
  .leg-list{display:flex;flex-direction:column;}
  .leg{
    display:flex;align-items:center;gap:0;
    border-bottom:1px solid rgba(0,0,0,.08);
  }
  .leg:last-child{border:none;}
  .leg-bar{
    width:4px;height:100%;min-height:28px;flex-shrink:0;
    align-self:stretch;
  }
  .leg-name{
    flex:1;padding:7px 10px;
    font-size:8px;letter-spacing:.12em;text-transform:uppercase;
    border-right:1px solid rgba(0,0,0,.08);color:#000;opacity:.5;
  }
  .leg-n{
    padding:7px 10px;font-size:9px;opacity:.3;min-width:28px;text-align:right;
  }
  .leg-n.on{opacity:1;}

  /* keywords */
  .kw{display:flex;flex-wrap:wrap;gap:4px;max-height:80px;overflow-y:auto;}
  .kw span{
    padding:2px 6px;font-size:8px;letter-spacing:.08em;text-transform:uppercase;
    border:1px solid rgba(0,0,0,.15);color:#000;
  }

  /* canvas stage */
  .stage{
    flex:1;overflow:auto;
    display:flex;align-items:flex-start;
    padding:32px 28px;background:#fff;
  }
  canvas{display:block;image-rendering:crisp-edges;}

  /* footer */
  .foot{
    border-top:1px solid #000;
    padding:8px 28px;
    font-size:8px;letter-spacing:.14em;text-transform:uppercase;
    color:#000;opacity:.35;
    display:flex;justify-content:space-between;
  }
</style>
</head>
<body>

<div class="topbar">
  <div class="logo">■ Emotion Grid Visualizer</div>
  <div class="right">
    <button class="btn" id="btnDl">Export PNG</button>
  </div>
</div>

<div class="layout">
  <div class="panel">

    <div class="panel-section">
      <div class="plabel">Input Text</div>
      <textarea id="inp">I love this app but it crashes now. Never again, I'm done.</textarea>
      <div class="brow">
        <button class="bprim" id="btnGen">Generate</button>
        <button class="bsec" id="btnRnd">↺</button>
      </div>
    </div>

    <div class="panel-section">
      <div class="plabel">Legend</div>
      <div class="leg-list" id="legEl"></div>
    </div>

    <div class="panel-section">
      <div class="plabel">Keywords</div>
      <div class="kw" id="kwEl"></div>
    </div>

  </div>
  <div class="stage"><canvas id="c"></canvas></div>
</div>

<div class="foot">
  <span>Each cell = one word · color = emotion type · height = intensity</span>
  <span id="fInfo">—</span>
</div>


<script>
(() => {
'use strict';

// ── EMOTION CONFIG ─────────────────────────────────────────────────
// 7 emotions, each with a distinct color matching our palette
const EMOTIONS = [
  { key:'basic_pos',   label:'Basic Positive',   color:'#00FF90', weight:0.30 },
  { key:'strong_pos',  label:'Strong Positive',  color:'#DFFF29', weight:0.50 },
  { key:'attach_pos',  label:'Emotional Attach', color:'#FF6134', weight:0.62 },
  { key:'extreme_pos', label:'Extreme Positive', color:'#F7399D', weight:0.82 },
  { key:'mild_neg',    label:'Mild Negative',    color:'#00FFFF', weight:0.32 },
  { key:'strong_neg',  label:'Strong Negative',  color:'#006AA0', weight:0.60 },
  { key:'extreme_neg', label:'Extreme Negative', color:'#020605', weight:0.88 },
];
const EMO_MAP = Object.fromEntries(EMOTIONS.map(e=>[e.key,e]));

// ── WORD SETS ──────────────────────────────────────────────────────
const WORD_MAP = new Map();
const SETS = {
  basic_pos:   ['good','nice','okay','fine','decent','works','working','useful','helpful','simple','easy','clean','smooth','clear','solid','reliable','convenient','comfortable','fair','reasonable','acceptable','satisfied','happy','not bad','pretty good'],
  strong_pos:  ['great','awesome','amazing','excellent','fantastic','wonderful','impressive','love it','so good','recommend','well done','brilliant','superb','incredible','outstanding','perfectly','really good','very good','highly recommend'],
  attach_pos:  ['love','loved','loving','favorite','favourite','obsessed','addicted','always','loyal','trust','feels','special','dear','fan','attached','every day','means','personal','go-to'],
  extreme_pos: ['best','perfect','life-changing','mind-blowing','flawless','must have','unbelievable','legendary','iconic','ultimate','five stars','10/10','no complaints','nothing better'],
  mild_neg:    ['slow','laggy','slightly','sometimes','confusing','unclear','not great','could be better','needs improvement','annoying','inconvenient','not ideal','meh','limited','minor','buggy','a bit'],
  strong_neg:  ['bad','terrible','poor','disappointing','frustrating','useless','waste','broken','hate','awful','ridiculous','unacceptable','glitchy','crashes','freezes','garbage','low quality','very bad'],
  extreme_neg: ['worst','never','again','delete','uninstall','done','scam','fraud','trash','junk','disaster','ruined','avoid','horrible','regret','never again','completely useless'],
};
for(const [emo,words] of Object.entries(SETS)){
  for(const w of words) WORD_MAP.set(w, emo);
}

// ── TOKENIZE: returns every word with emo tag ──────────────────────
function tokenize(text){
  const words = text.toLowerCase()
    .split(/\s+/)
    .map(t=>t.replace(/[^\w']/g,''))
    .filter(Boolean);
  const result = [];
  for(let i=0;i<words.length;i++){
    const bi = words[i]+' '+(words[i+1]||'');
    if(WORD_MAP.has(bi)){
      result.push({word:bi, emo:WORD_MAP.get(bi)});
      i++;
    } else {
      result.push({word:words[i], emo:WORD_MAP.has(words[i])?WORD_MAP.get(words[i]):null});
    }
  }
  return result;
}

// ── DRAW ──────────────────────────────────────────────────────────
const canvas = document.getElementById('c');
const ctx    = canvas.getContext('2d');
let lastText = '';

function draw(text){
  lastText = text;
  const words  = tokenize(text);
  const N      = words.length;
  if(!N) return;

  const counts = {};
  for(const e of EMOTIONS) counts[e.key]=0;
  for(const w of words) if(w.emo) counts[w.emo]++;

  const DPR    = window.devicePixelRatio||1;

  // ── Layout ─────────────────────────────────────────────────────
  const CELL_W  = 46;    // width per word cell
  const ROW_H   = 160;   // height of the color block area
  const RULER_H = 18;    // ruler strip below
  const INDEX_H = 20;    // circle index row above
  const GAP     = 18;    // gap between the two rows
  const PAD_L   = 8;
  const PAD_T   = 10;
  const PAD_B   = 12;

  // Two rows: row0 = positive emotions, row1 = negative emotions
  // Both show ALL emotion colors, split by pos/neg for clarity
  const ROWS = 2;
  const totalW = PAD_L*2 + N*CELL_W;
  const totalH = PAD_T + ROWS*(INDEX_H+ROW_H+RULER_H) + (ROWS-1)*GAP + PAD_B;

  canvas.width  = totalW * DPR;
  canvas.height = totalH * DPR;
  canvas.style.width  = totalW+'px';
  canvas.style.height = totalH+'px';
  ctx.setTransform(DPR,0,0,DPR,0,0);

  // White canvas bg
  ctx.fillStyle='#ffffff';
  ctx.fillRect(0,0,totalW,totalH);

  const rowY = [
    PAD_T,
    PAD_T + INDEX_H + ROW_H + RULER_H + GAP,
  ];

  // Row 0: positive emotions
  drawRow(words, N, rowY[0], CELL_W, ROW_H, RULER_H, INDEX_H, PAD_L, totalW,
    ['basic_pos','strong_pos','attach_pos','extreme_pos'], 0);

  // Row 1: negative emotions
  drawRow(words, N, rowY[1], CELL_W, ROW_H, RULER_H, INDEX_H, PAD_L, totalW,
    ['mild_neg','strong_neg','extreme_neg'], 1);

  // ── Sidebar ────────────────────────────────────────────────────
  document.getElementById('legEl').innerHTML = EMOTIONS.map(e=>{
    const c=counts[e.key]||0;
    return `<div class="leg">
      <div class="leg-bar" style="background:${e.color}"></div>
      <span class="leg-name">${e.label}</span>
      <span class="leg-n ${c>0?'on':''}">${c||'·'}</span>
    </div>`;
  }).join('');

  document.getElementById('kwEl').innerHTML = words.filter(w=>w.emo).map(w=>
    `<span style="border-color:${EMO_MAP[w.emo].color}66;color:${EMO_MAP[w.emo].color}">${w.word}</span>`
  ).join('')||`<span style="opacity:.3">No keywords</span>`;

  document.getElementById('fInfo').textContent =
    `${N} words · ${words.filter(w=>w.emo).length} keywords · ${Object.values(counts).filter(v=>v>0).length} emotion types`;
}

// ── ROW RENDERER ──────────────────────────────────────────────────
function drawRow(words, N, yTop, cellW, rowH, rulerH, indexH, padL, totalW, emoKeys, rowIdx){
  const bandY = yTop + indexH; // where the block area starts

  // ── 1. Circle index row ──────────────────────────────────────
  ctx.textAlign    = 'center';
  ctx.textBaseline = 'middle';
  ctx.font         = `7px 'DM Mono', monospace`;

  for(let i=0;i<N;i++){
    const cx = padL + i*cellW + cellW/2;
    const cy = yTop + indexH/2;

    // circles and numbers hidden
  }

  // ── 2. No solid grid background — transparent ────────────────────
  // (removed fill so stripes show cleanly on canvas bg)

  // ── 3. Vertical cell dividers (very faint, drawn AFTER stripes) ──
  // deferred to after stripe rendering

  // ── 4. Continuous stripe across the entire row ───────────────────
  // Instead of per-cell blocks, draw ONE continuous stripe pass
  // across the full row width. Each stripe column samples the
  // interpolated {weight, R, G, B} at that exact x position.

  // Build per-cell interpolated values (same logic as before)
  const anchors = new Array(N).fill(null);
  for(let i=0;i<N;i++){
    const w = words[i];
    if(w.emo && emoKeys.includes(w.emo)){
      const emo = EMO_MAP[w.emo];
      const [R,G,B] = hexToRGB(emo.color);
      anchors[i] = { weight: emo.weight, R, G, B };
    }
  }

  const hasAnyAnchor = anchors.some(a=>a!==null);
  const cellValues = new Array(N);

  if(!hasAnyAnchor){
    for(let i=0;i<N;i++) cellValues[i]={ weight:0.0, R:180, G:180, B:180 };
  } else {
    for(let i=0;i<N;i++){
      if(anchors[i]){ cellValues[i]=anchors[i]; continue; }
      let prevIdx=-1, nextIdx=-1;
      for(let k=i-1;k>=0;k--){ if(anchors[k]){prevIdx=k;break;} }
      for(let k=i+1;k<N;k++){ if(anchors[k]){nextIdx=k;break;} }

      if(prevIdx===-1&&nextIdx===-1){
        cellValues[i]={weight:0.0,R:180,G:180,B:180};
      } else if(prevIdx===-1){
        const a=anchors[nextIdx], dist=nextIdx-i;
        const f=Math.max(0.0, 1-dist*0.14);
        cellValues[i]={weight:a.weight*f,R:a.R,G:a.G,B:a.B};
      } else if(nextIdx===-1){
        const a=anchors[prevIdx], dist=i-prevIdx;
        const f=Math.max(0.0, 1-dist*0.14);
        cellValues[i]={weight:a.weight*f,R:a.R,G:a.G,B:a.B};
      } else {
        const prev=anchors[prevIdx], next=anchors[nextIdx];
        const span=nextIdx-prevIdx;
        const t=(i-prevIdx)/span;
        const s=t*t*(3-2*t); // smoothstep
        cellValues[i]={
          weight: prev.weight+(next.weight-prev.weight)*s,
          R: Math.round(prev.R+(next.R-prev.R)*s),
          G: Math.round(prev.G+(next.G-prev.G)*s),
          B: Math.round(prev.B+(next.B-prev.B)*s),
        };
      }
    }
  }

  // Helper: sample interpolated value at fractional cell position x (0..N)
  function sampleAt(x){
    const i0 = Math.floor(x);
    const i1 = Math.min(i0+1, N-1);
    const frac = x - i0;
    const s = frac*frac*(3-2*frac); // smoothstep within cell
    const a = cellValues[Math.max(0,i0)];
    const b = cellValues[i1];
    return {
      weight: a.weight+(b.weight-a.weight)*s,
      R: Math.round(a.R+(b.R-a.R)*s),
      G: Math.round(a.G+(b.G-a.G)*s),
      B: Math.round(a.B+(b.B-a.B)*s),
    };
  }

  // Draw continuous stripes — WIDTH scales with emotion intensity
  // strong emotion → wide stripes packed tight (dramatic)
  // weak/neutral   → thin stripes spread apart (calm)
  const STRIPE_W_MIN = 0.7;
  const STRIPE_W_MAX = 8.0;
  const GAP_MIN      = 0.0;
  const GAP_MAX      = 0.0;
  const totalBandW   = N * cellW;

  let sx = padL;
  while(sx < padL + totalBandW){
    const cellX = Math.min((sx - padL) / cellW, N - 0.001);
    const cv    = sampleAt(cellX);
    const { weight, R, G, B } = cv;

    const sw    = STRIPE_W_MIN + (STRIPE_W_MAX - STRIPE_W_MIN) * weight;
    const gap   = GAP_MAX - (GAP_MAX - GAP_MIN) * weight;
    const pitch = sw + gap;

    if(weight > 0.01){
      const blockH = Math.round(rowH * weight);
      const blockY = bandY + rowH - blockH;

      // Flat full-opacity fill — crisp and vivid
      ctx.fillStyle = `rgb(${R},${G},${B})`;
      ctx.fillRect(sx, blockY, sw, blockH);
    }

    sx += pitch;
  }

  // ── 3. Cell dividers on top of stripes (very faint) ──────────────
  ctx.strokeStyle = 'rgba(0,0,0,.07)';
  ctx.lineWidth   = 0.4;
  for(let i=1;i<N;i++){
    const x = padL + i*cellW;
    ctx.beginPath();
    ctx.moveTo(x, bandY);
    ctx.lineTo(x, bandY+rowH);
    ctx.stroke();
  }
  // Band border
  ctx.strokeStyle = 'rgba(0,0,0,.15)';
  ctx.lineWidth   = 0.5;
  ctx.beginPath();ctx.moveTo(padL,bandY);ctx.lineTo(padL+N*cellW,bandY);ctx.stroke();
  ctx.beginPath();ctx.moveTo(padL,bandY+rowH);ctx.lineTo(padL+N*cellW,bandY+rowH);ctx.stroke();

  // ── 5. Ruler — one tick per word ────────────────────────────
  const ry = bandY + rowH;

  // Thin baseline
  ctx.strokeStyle = 'rgba(0,0,0,.18)';
  ctx.lineWidth   = 0.5;
  ctx.beginPath();ctx.moveTo(padL,ry);ctx.lineTo(padL+N*cellW,ry);ctx.stroke();

  // One vertical tick per word boundary
  for(let i=0;i<=N;i++){
    const x = padL + i*cellW;
    const isMaj = i%5===0;
    const tickH = isMaj ? rulerH : rulerH*0.5;
    ctx.strokeStyle = isMaj ? 'rgba(0,0,0,.28)' : 'rgba(0,0,0,.14)';
    ctx.lineWidth   = isMaj ? 0.6 : 0.4;
    ctx.beginPath();ctx.moveTo(x,ry);ctx.lineTo(x,ry+tickH);ctx.stroke();
  }

  // Bottom border
  ctx.strokeStyle='rgba(0,0,0,.10)';ctx.lineWidth=0.4;
  ctx.beginPath();ctx.moveTo(padL,ry+rulerH);ctx.lineTo(padL+N*cellW,ry+rulerH);ctx.stroke();
}

// ── UTILS ─────────────────────────────────────────────────────────
function hexToRGB(hex){
  return [parseInt(hex.slice(1,3),16),parseInt(hex.slice(3,5),16),parseInt(hex.slice(5,7),16)];
}
function lighten(hex, amt){
  const r=parseInt(hex.slice(1,3),16);
  const g=parseInt(hex.slice(3,5),16);
  const b=parseInt(hex.slice(5,7),16);
  return `rgb(${Math.min(255,Math.round(r+(255-r)*amt))},${Math.min(255,Math.round(g+(255-g)*amt))},${Math.min(255,Math.round(b+(255-b)*amt))})`;
}

// ── EVENTS ────────────────────────────────────────────────────────
const inp = document.getElementById('inp');
document.getElementById('btnGen').addEventListener('click',()=>draw(inp.value));
document.getElementById('btnRnd').addEventListener('click',()=>draw(inp.value));
document.getElementById('btnDl').addEventListener('click',()=>{
  const a=document.createElement('a');
  a.href=canvas.toDataURL('image/png');
  a.download='emotion-grid.png';a.click();
});

let db;
inp.addEventListener('input',()=>{clearTimeout(db);db=setTimeout(()=>draw(inp.value),280);});
window.addEventListener('resize',()=>draw(lastText||inp.value));

draw(inp.value);
})();
</script>
</body>
</html>
