<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Emotion X-ray Generator</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 24px; }
    .wrap { display: grid; grid-template-columns: 360px 1fr; gap: 16px; align-items: start; }
    textarea { width: 100%; height: 180px; padding: 10px; font-size: 14px; }
    button { padding: 10px 12px; font-size: 14px; cursor: pointer; }
    .row { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 10px; }
    .hint { font-size: 12px; color: #444; line-height: 1.5; margin-top: 10px; }
    canvas { width: 100%; max-width: 1100px; border: 1px solid #ddd; background: #fff; }
    .pill { display:inline-block; padding: 2px 8px; border-radius: 999px; background:#f3f3f3; font-size:12px; margin-right:6px;}
    .legend { display:flex; flex-wrap:wrap; gap:8px; margin-top:10px;}
    .swatch { display:flex; align-items:center; gap:6px; font-size:12px; }
    .box { width:14px; height:14px; border:1px solid #0002; }
  </style>
</head>
<body>
  <h1 style="margin:0 0 10px 0;">Emotion X-ray Generator</h1>

  <div class="wrap">
    <div>
      <textarea id="input">i love apps but it crashes now</textarea>

      <div class="row">
        <button id="btnGen">Generate</button>
        <button id="btnDownload">Download PNG</button>
        <button id="btnRandomize">Randomize seed</button>
      </div>

      <div class="hint">
        <div><span class="pill">Shape</span> Type 1(1인칭 시작) → Type 2(접속사 등장부터) → Type 3(시간 표현 등장부터) → Type 4(단절 선언부터 종료)</div>
        <div style="margin-top:6px;"><span class="pill">Color</span> 7단계 팔레트(네가 준 HEX)를 감정 키워드 매칭으로 선택</div>
        <div style="margin-top:6px;"><span class="pill">Tip</span> “but / however / though”, “now / still / again”, “delete / uninstall / done / never again” 같은 단어 넣어보면 타입 전환이 확 보임</div>
      </div>

      <div class="legend" id="legend"></div>
    </div>

    <div>
      <canvas id="c" width="1400" height="900"></canvas>
    </div>
  </div>

<script>
(() => {
  // =========================
  // 1) COLOR PALETTE (user-defined)
  // =========================
  const COLORS = {
    basic_pos:   "#00FF90", // 기본 긍정
    strong_pos:  "#DFFF29", // 강화 긍정
    attach_pos:  "#FF6134", // 감정 애착
    extreme_pos: "#F7399D", // 극단 긍정
    mild_neg:    "#00FFFF", // 약한 불만
    strong_neg:  "#006AA0", // 강한 불만
    extreme_neg: "#020605", // 극단 부정
  };

  // legend
  const legendEl = document.getElementById("legend");
  const legendItems = [
    ["기본 긍정", COLORS.basic_pos],
    ["강화 긍정", COLORS.strong_pos],
    ["감정 애착", COLORS.attach_pos],
    ["극단 긍정", COLORS.extreme_pos],
    ["약한 불만", COLORS.mild_neg],
    ["강한 불만", COLORS.strong_neg],
    ["극단 부정", COLORS.extreme_neg],
  ];
  legendItems.forEach(([name, hex]) => {
    const d = document.createElement("div");
    d.className = "swatch";
    d.innerHTML = `<span class="box" style="background:${hex}"></span>${name} (${hex})`;
    legendEl.appendChild(d);
  });

  // =========================
  // 2) KEYWORDS (extend as you like)
  //    - 이건 "색 분류" 용. (모양은 구조 신호로 전환)
  // =========================
  const KW = {
    // Positive
    basic_pos: new Set(["good","nice","helpful","useful","easy","simple","convenient","cool","fun","works","reliable","smooth","accurate","decent","fine","okay"]),
    strong_pos: new Set(["great","excellent","fantastic","wonderful","impressed","powerful","brilliant","outstanding","productive","valuable"]),
    attach_pos: new Set(["love","loved","loving","favorite","favourite","obsessed","addicted","bestie","sister","everything","blessing","grateful","indispensable"]),
    extreme_pos: new Set(["best","perfect","10/10","five","stars","must-have","life-changing","beyond","mind","blowing","goat"]),

    // Negative
    mild_neg: new Set(["slow","laggy","buggy","glitchy","glitch","annoying","confusing","frustrating","limited","not","working","issue","problem","crash","crashes","freeze","freezes","stutter"]),
    strong_neg: new Set(["bad","terrible","horrible","ridiculous","unacceptable","useless","waste","misleading","unfair","overpriced","greedy"]),
    extreme_neg: new Set(["worst","scam","scammers","fraud","toxic","disgusting","trash","junk","poison","delete","uninstall","bye","done","never","again"]),
  };

  // =========================
  // 3) SHAPE TRIGGERS (모양 전환)
  // =========================
  const TRIG = {
    type2_contrast: new Set(["but","however","though","although","yet"]),
    type3_time: new Set(["now","still","again","anymore","since","lately","recently","today","yesterday","always"]),
    type4_break: new Set(["delete","uninstall","bye","done"]), // plus "never again" handled separately
  };

  // =========================
  // 4) TOKENIZE
  // =========================
  function tokenize(text) {
    // keep simple: words + numbers + / + '
    return (text || "")
      .trim()
      .split(/\s+/g)
      .map(t => t.replace(/[^\w'\/-]/g, "")) // strip punctuation
      .filter(Boolean);
  }

  // helper: detect "never again" bigram
  function hasNeverAgain(tokens, i) {
    return (tokens[i] === "never" && tokens[i+1] === "again");
  }

  // =========================
  // 5) COLOR PICK: based on keyword hits
  // =========================
  function pickColorForSegment(segTokens) {
    const hits = {
      basic_pos: 0, strong_pos: 0, attach_pos: 0, extreme_pos: 0,
      mild_neg: 0, strong_neg: 0, extreme_neg: 0,
    };

    for (const raw of segTokens) {
      const t = raw.toLowerCase();

      // special cases
      if (t === "10/10") hits.extreme_pos += 2;

      for (const k in KW) {
        if (KW[k].has(t)) hits[k] += 1;
      }
    }

    // pick max
    let bestK = "basic_pos";
    let bestV = -1;
    for (const k in hits) {
      if (hits[k] > bestV) { bestV = hits[k]; bestK = k; }
    }

    // if no hits at all, default basic_pos (or you can choose a neutral)
    if (bestV <= 0) return { key: "basic_pos", hex: COLORS.basic_pos, strength: 0 };
    return { key: bestK, hex: COLORS[bestK], strength: bestV };
  }

  // =========================
  // 6) SHAPE TYPE SCAN: sentence progresses left->right; type switches at triggers
  // =========================
  function shapeTypeAt(tokens, idx, currentType) {
    const t = tokens[idx]?.toLowerCase();

    // TYPE 4: break (hard stop)
    if (hasNeverAgain(tokens.map(x=>x.toLowerCase()), idx)) return 4;
    if (TRIG.type4_break.has(t)) return 4;

    // TYPE 3: time
    if (TRIG.type3_time.has(t)) return 3;

    // TYPE 2: contrast
    if (TRIG.type2_contrast.has(t)) return 2;

    // Otherwise keep current
    return currentType;
  }

  // TYPE 1 init: starts with first-person
  function initialType(tokens) {
    const first = tokens[0]?.toLowerCase();
    if (first === "i" || first === "i'm" || first === "im" || first === "my") return 1;
    return 1; // default: 1 (you asked for 1인칭이면 1번, 아니어도 기본 흐름은 1로 시작하는 게 보기 좋음)
  }

  // =========================
  // 7) DRAW PRIMITIVES
  // =========================
  let seed = 12345;
  function rand() {
    // deterministic RNG
    seed = (seed * 1664525 + 1013904223) % 4294967296;
    return seed / 4294967296;
  }

  function roundedRect(ctx, x, y, w, h, r) {
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  // =========================
  // 8) GENERATE LAYOUT
  // =========================
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  function clearCanvas() {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0,0,canvas.width,canvas.height);
  }

  function draw(text) {
    clearCanvas();

    const tokens = tokenize(text);
    if (!tokens.length) return;

    // We'll render as horizontal "scanline" blocks with wrapping.
    const margin = 70;
    let x = margin;
    let y = margin;
    const lineH = 64;     // distance between rows
    const maxX = canvas.width - margin;

    let type = initialType(tokens);

    // We’ll keep segments: same TYPE runs are grouped so color can differ per run
    let run = [];
    let runType = type;

    function flushRun() {
      if (!run.length) return;

      // color per run based on keyword hits inside this run
      const col = pickColorForSegment(run);
      const hex = col.hex;

      // visual parameters by type
      // NOTE: 모양은 "말하는 방식(구조)"만 담당.
      const baseH = (runType === 1) ? 22 : (runType === 2) ? 14 : (runType === 3) ? 10 : 44;
      const blur = (runType === 3) ? 0 : 0; // keep crisp; you can add blur via ctx.filter if needed
      const radius = (runType === 1) ? 8 : (runType === 2) ? 3 : (runType === 4) ? 2 : 6;

      // strength influences opacity and slight size
      const opacity = Math.min(0.95, 0.25 + (col.strength * 0.12));
      const h = baseH + Math.min(18, col.strength * 2);

      // Build geometry for each token in run, sequentially
      for (let i=0; i<run.length; i++) {
        const raw = run[i];
        const t = raw.toLowerCase();
        const w = Math.max(28, Math.min(320, raw.length * 18 + 20)); // width by token length

        // wrap
        if (x + w > maxX) {
          x = margin;
          y += lineH;
          if (y > canvas.height - margin - lineH) break;
        }

        // jitter for organic (very small)
        const jx = (rand() - 0.5) * 6;
        const jy = (rand() - 0.5) * 6;

        ctx.save();
        ctx.globalAlpha = opacity;
        ctx.fillStyle = hex;

        if (blur) ctx.filter = `blur(${blur}px)`;

        if (runType === 1) {
          // TYPE 1: thick stable bar
          roundedRect(ctx, x + jx, y + jy, w, h, radius);
          ctx.fill();

        } else if (runType === 2) {
          // TYPE 2: contrast -> "broken bar"
          const gap = 10 + rand()*10;
          const w1 = Math.max(12, w * (0.45 + rand()*0.15));
          const w2 = Math.max(12, w - w1 - gap);
          roundedRect(ctx, x + jx, y + jy, w1, h, radius);
          ctx.fill();
          roundedRect(ctx, x + jx + w1 + gap, y + jy + (rand()-0.5)*6, w2, h, radius);
          ctx.fill();

        } else if (runType === 3) {
          // TYPE 3: time -> dots/repetition
          const dots = Math.max(3, Math.floor(w / 26));
          for (let d=0; d<dots; d++) {
            const dx = x + (d * (w / dots)) + (rand()-0.5)*8;
            const dy = y + (h/2) + (rand()-0.5)*10;
            const r = 4 + rand()*8 + Math.min(10, col.strength);
            ctx.beginPath();
            ctx.arc(dx, dy, r, 0, Math.PI*2);
            ctx.fill();
          }

        } else if (runType === 4) {
          // TYPE 4: break -> big terminal block then STOP
          const W = Math.min(520, w + 220);
          const H = Math.min(140, h + 60);
          const yy = y + jy - 10;
          roundedRect(ctx, x + jx, yy, W, H, 4);
          ctx.fill();
          ctx.restore();

          // stop rendering further content
          x = margin;
          y += lineH;
          run.length = 0;
          return "STOP";
        }

        ctx.restore();
        x += w + 16; // spacing
      }

      run = [];
      return "OK";
    }

    // scan tokens and build runs by TYPE changes
    for (let i=0; i<tokens.length; i++) {
      const low = tokens[i].toLowerCase();

      // decide next type at this token boundary
      const nextType = shapeTypeAt(tokens.map(x=>x.toLowerCase()), i, type);

      // if type changes, flush current run
      if (nextType !== type) {
        const res = flushRun();
        if (res === "STOP") return;
        type = nextType;
        runType = type;
      }

      // push token to run
      run.push(tokens[i]);

      // if the token itself triggers Type4 ("never again" bigram), flush immediately to stop
      if (type === 4) {
        const res = flushRun();
        if (res === "STOP") return;
      }

      // handle bigram consumption for "never again"
      if (hasNeverAgain(tokens.map(x=>x.toLowerCase()), i)) {
        // include "again" as well in the current run, then stop
        if (i+1 < tokens.length) run.push(tokens[i+1]);
        const res = flushRun();
        return;
      }
    }

    flushRun();
  }

  // =========================
  // 9) UI
  // =========================
  const inputEl = document.getElementById("input");
  document.getElementById("btnGen").addEventListener("click", () => draw(inputEl.value));

  document.getElementById("btnDownload").addEventListener("click", () => {
    const a = document.createElement("a");
    a.href = canvas.toDataURL("image/png");
    a.download = "emotion-xray.png";
    a.click();
  });

  document.getElementById("btnRandomize").addEventListener("click", () => {
    seed = Math.floor(Math.random() * 1e9);
    draw(inputEl.value);
  });

  // first render
  draw(inputEl.value);
})();
</script>
</body>
</html>
