<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Emotion Waveform</title>
<style>
  :root{
    /* WHITE UI SYSTEM */
    --bg:#ffffff;
    --panel:#ffffff;
    --panel2:#f6f6f6;
    --ink:#111111;
    --muted:rgba(0,0,0,.55);
    --line:rgba(0,0,0,.14);
    --shadow:rgba(0,0,0,.06);

    /* Accent (matches your extreme_pos) */
    --accent:#F7399D;
  }

  *{ box-sizing:border-box; }
  body{
    margin:0;
    background:var(--bg);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
    color:var(--ink);
  }

  .app{
    display:grid;
    grid-template-columns: 420px 1fr;
    min-height:100vh;
    gap:24px;
    padding:28px;
  }

  /* Left column */
  .ui{
    position:sticky;
    top:20px;
    align-self:start;
  }

  .topbar{
    display:flex;
    gap:10px;
    align-items:center;
    margin-bottom:14px;
  }

  .tab{
    background:var(--panel);
    border:1px solid var(--line);
    padding:12px 16px;
    font-size:12px;
    letter-spacing:.10em;
    text-transform:uppercase;
    box-shadow: 0 1px 0 var(--shadow);
    user-select:none;
  }

  .btn-save{
    margin-left:auto;
    background:var(--panel);
    border:1px solid var(--line);
    padding:12px 16px;
    font-size:12px;
    letter-spacing:.10em;
    text-transform:uppercase;
    cursor:pointer;
    box-shadow: 0 1px 0 var(--shadow);
  }
  .btn-save:hover{ background:var(--panel2); }

  .panel{
    background:var(--panel);
    border:1px solid var(--line);
    box-shadow: 0 2px 0 var(--shadow);
    padding:14px;
    margin-bottom:16px;
  }

  .panel h3{
    margin:0 0 10px 0;
    font-size:12px;
    letter-spacing:.10em;
    text-transform:uppercase;
    color:var(--muted);
  }

  textarea{
    width:100%;
    height:140px;
    resize:none;
    padding:10px;
    font-size:13px;
    line-height:1.45;
    color:var(--ink);
    background:var(--panel2);
    border:1px solid var(--line);
    outline:none;
  }

  .actions{
    display:flex;
    gap:10px;
    margin-top:10px;
  }

  .btn{
    flex:1;
    background:var(--panel);
    border:1px solid var(--line);
    padding:12px 12px;
    font-size:12px;
    letter-spacing:.10em;
    text-transform:uppercase;
    cursor:pointer;
    box-shadow: 0 1px 0 var(--shadow);
  }
  .btn:hover{ background:var(--panel2); }

  /* Status panel */
  .status{
    display:grid;
    grid-template-columns: 1fr;
    gap:10px;
  }

  .kv{
    display:grid;
    grid-template-columns: 120px 1fr;
    gap:10px;
    padding:10px;
    border:1px solid var(--line);
    background:var(--panel);
  }
  .k{
    font-size:11px;
    letter-spacing:.08em;
    text-transform:uppercase;
    color:var(--muted);
  }
  .v{
    font-size:12px;
    color:var(--ink);
    display:flex;
    align-items:center;
    gap:10px;
    flex-wrap:wrap;
  }

  .chip{
    display:inline-flex;
    align-items:center;
    gap:8px;
    padding:6px 10px;
    border:1px solid var(--line);
    background:var(--panel);
    font-size:12px;
  }
  .sw{
    width:12px;
    height:12px;
    border:1px solid rgba(0,0,0,.12);
  }

  .meter{
    height:8px;
    width:180px;
    border:1px solid var(--line);
    background:var(--panel2);
    position:relative;
    border-radius:2px;
    overflow:hidden;
  }
  .meter > span{
    position:absolute;
    left:0; top:0; bottom:0;
    width:0%;
    background:var(--accent);
  }

  .note{
    font-size:12px;
    color:var(--muted);
    line-height:1.5;
  }

  /* Right stage */
  .stage{
    display:flex;
    align-items:center;
    justify-content:center;
    padding:18px 0;
  }
  canvas{
    width:100%;
    max-width:1400px;
    background:transparent;
  }

  @media (max-width: 980px){
    .app{ grid-template-columns: 1fr; }
    .ui{ position:relative; top:auto; }
  }
</style>
</head>
<body>

<div class="app">
  <!-- LEFT UI -->
  <div class="ui">
    <div class="topbar">
      <div class="tab">STATUS</div>
      <button class="btn-save" id="btnSaveTop">SAVE</button>
    </div>

    <div class="panel">
      <h3>Input</h3>
      <textarea id="input">I love this app but it crashes now. Never again, I'm done.</textarea>
      <div class="actions">
        <button class="btn" id="btnGen">GENERATE</button>
        <button class="btn" id="btnRandom">RANDOMIZE</button>
      </div>
      <div class="note" style="margin-top:10px;">
        * 컨트롤 UI는 최소화하고, 결과에 대한 <b>상태값(analysis)</b>만 표시합니다.
      </div>
    </div>

    <div class="panel">
      <h3>Analysis</h3>
      <div class="status">
        <div class="kv">
          <div class="k">Sentences</div>
          <div class="v" id="statSentences">—</div>
        </div>

        <div class="kv">
          <div class="k">Overall emotion</div>
          <div class="v">
            <span class="chip"><span class="sw" id="swOverall"></span><span id="statOverall">—</span></span>
          </div>
        </div>

        <div class="kv">
          <div class="k">Intensity</div>
          <div class="v">
            <div class="meter"><span id="barIntensity"></span></div>
            <span id="statIntensity">—</span>
          </div>
        </div>

        <div class="kv">
          <div class="k">Switches</div>
          <div class="v" id="statSwitches">—</div>
        </div>

        <div class="kv">
          <div class="k">Used colors</div>
          <div class="v" id="statColors">—</div>
        </div>
      </div>

      <div class="note" style="margin-top:10px;">
        Switch 규칙: <b>but/however…</b> → broken, <b>now/still…</b> → periodic, <b>delete/done/never again</b> → spike+decay end
      </div>
    </div>

    <div class="panel">
      <h3>Export</h3>
      <div class="actions">
        <button class="btn" id="btnDownload">DOWNLOAD PNG</button>
        <button class="btn" id="btnSaveBottom">SAVE</button>
      </div>
    </div>
  </div>

  <!-- RIGHT STAGE -->
  <div class="stage">
    <canvas id="c" width="1800" height="900"></canvas>
  </div>
</div>

<script>
(() => {
  // ===== palette (your hex) =====
  const COLORS = {
    basic_pos:"#00FF90",
    strong_pos:"#DFFF29",
    attach_pos:"#FF6134",
    extreme_pos:"#F7399D",
    mild_neg:"#00FFFF",
    strong_neg:"#006AA0",
    extreme_neg:"#020605"
  };

  // label for status panel
  const LABEL = {
    basic_pos:"basic positive",
    strong_pos:"strong positive",
    attach_pos:"attachment",
    extreme_pos:"extreme positive",
    mild_neg:"mild complaint",
    strong_neg:"strong complaint",
    extreme_neg:"extreme negative"
  };

  // ===== minimal keyword starter for coloring =====
  const KW = {
    attach_pos:new Set(["love","loved","loving","favorite","favourite","obsessed","addicted"]),
    strong_pos:new Set(["great","amazing","excellent","fantastic"]),
    basic_pos:new Set(["good","nice","helpful","useful","easy","works"]),
    mild_neg:new Set(["slow","laggy","buggy","glitch","glitchy","annoying","confusing","crash","crashes","freeze","freezes"]),
    strong_neg:new Set(["bad","terrible","broken","unacceptable","overpriced"]),
    extreme_neg:new Set(["worst","scam","fraud","trash","junk","delete","uninstall","done","never","again"])
  };

  const TRIG = {
    contrast: new Set(["but","however","though","although","yet"]),
    time: new Set(["now","still","again","anymore","since","lately","recently","already"]),
    break: new Set(["delete","uninstall","bye","done"]),
  };

  // pitch (0..1) higher -> upper
  const BASE_PITCH = {
    basic_pos: 0.44,
    strong_pos: 0.58,
    attach_pos: 0.70,
    extreme_pos: 0.86,
    mild_neg: 0.36,
    strong_neg: 0.55,
    extreme_neg: 0.22
  };

  function splitSentences(text){
    return (text||"")
      .split(/[\n\r]+|(?<=[.!?])\s+/g)
      .map(s=>s.trim())
      .filter(Boolean);
  }
  function tokenize(sentence){
    return sentence.trim().split(/\s+/g)
      .map(t=>t.replace(/[^\w'\/-]/g,""))
      .filter(Boolean);
  }
  function hasNeverAgain(tokensLower,i){
    return tokensLower[i]==="never" && tokensLower[i+1]==="again";
  }

  // RNG
  let seed = 1234567;
  function rand(){
    seed = (seed*1664525 + 1013904223) % 4294967296;
    return seed/4294967296;
  }
  function randRange(a,b){ return a + (b-a)*rand(); }

  function scoreHits(tokens){
    const hits = {
      basic_pos:0,strong_pos:0,attach_pos:0,extreme_pos:0,
      mild_neg:0,strong_neg:0,extreme_neg:0
    };
    for(const raw of tokens){
      const t = raw.toLowerCase();
      for(const k in KW){
        if(KW[k].has(t)) hits[k] += 1;
      }
      if(t==="10/10") hits.extreme_pos += 2;
    }
    return hits;
  }

  function pickCategory(tokens){
    const hits = scoreHits(tokens);
    let best="basic_pos", bestV=-1;
    for(const k in hits){
      if(hits[k] > bestV){ bestV = hits[k]; best = k; }
    }
    if(bestV<=0) return {key:"basic_pos", hex:COLORS.basic_pos, hitCount:0};
    return {key:best, hex:COLORS[best], hitCount:bestV};
  }

  function intensityFromTokens(tokens){
    // 0..10
    const hits = scoreHits(tokens);
    const sumHits = Object.values(hits).reduce((a,b)=>a+b,0);
    const lenBoost = Math.min(3, Math.floor(tokens.length/6));
    const base = sumHits*2 + lenBoost;
    return Math.max(0, Math.min(10, base));
  }

  function ampFromIntensity(intensity, staffH){
    return 8 + (intensity/10) * (staffH * 0.36);
  }

  function alphaFromIntensity(intensity){
    return Math.min(0.92, 0.20 + (intensity/10) * 0.70);
  }

  function nextMode(tokensLower,i,cur){
    if(hasNeverAgain(tokensLower,i)) return 4;
    const t = tokensLower[i];
    if(TRIG.break.has(t)) return 4;
    if(TRIG.time.has(t)) return 3;
    if(TRIG.contrast.has(t)) return 2;
    return cur;
  }

  // ===== canvas draw =====
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  function clearCanvas(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // white background explicitly
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0,0,canvas.width,canvas.height);
  }

  function yFromPitch(pitch01, yTop, staffH){
    return yTop + (1 - pitch01) * staffH;
  }

  function drawWaveFilled(xs, amps, yCenter, colorHex, alpha){
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = colorHex;

    ctx.beginPath();
    ctx.moveTo(xs[0], yCenter - amps[0]);
    for(let i=1;i<xs.length;i++) ctx.lineTo(xs[i], yCenter - amps[i]);
    for(let i=xs.length-1;i>=0;i--) ctx.lineTo(xs[i], yCenter + amps[i]);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  function drawSentenceWave(sentence, yTop, staffH, usedColors){
    const tokens = tokenize(sentence);
    const tokensLower = tokens.map(t=>t.toLowerCase());
    if(!tokens.length) return { switches: [] };

    const overallCat = pickCategory(tokens);
    const overallIntensity = intensityFromTokens(tokens);
    usedColors.add(overallCat.key);

    let pitch = (BASE_PITCH[overallCat.key] ?? 0.52) + randRange(-0.02, 0.02);
    pitch = Math.max(0.06, Math.min(0.94, pitch));
    const yCenter = yFromPitch(pitch, yTop, staffH);

    const xStart = 120;
    const xEnd = canvas.width - 120;
    const usableW = xEnd - xStart;

    const weights = tokens.map(t=>Math.max(1.0, Math.min(10, t.length/3)));
    const totalW = weights.reduce((a,b)=>a+b,0);

    let mode = 1;
    let runTokens = [];
    let runWeight = 0;
    let xCursor = xStart;

    const switches = [];

    function drawRun(runTokensLocal, runW, modeLocal){
      if(!runTokensLocal.length || runW <= 2) return { stop:false };

      const cat = pickCategory(runTokensLocal);
      const inten = intensityFromTokens(runTokensLocal);
      const ampMax = ampFromIntensity(inten, staffH);
      const alpha = alphaFromIntensity(inten);
      usedColors.add(cat.key);

      const N = Math.max(160, Math.floor(runW/3));
      const xs = new Array(N);
      const amps = new Array(N);

      for(let i=0;i<N;i++){
        const t = i/(N-1);
        xs[i] = xCursor + t * runW;

        if(modeLocal === 1){
          const noise = (rand()-0.5)*0.55;
          const env = 0.55 + 0.45*Math.sin(t*Math.PI);
          amps[i] = Math.max(0, ampMax * env * (0.55 + noise));

        }else if(modeLocal === 2){
          const dropout = (rand() < 0.07) ? 0.0 : 1.0;
          const noise = (rand()-0.5)*1.25;
          const env = 0.35 + 0.65*Math.sin(t*Math.PI);
          amps[i] = Math.max(0, ampMax * env * Math.max(0, 0.65 + noise) * dropout);

        }else if(modeLocal === 3){
          const freq = randRange(10,18);
          const vib = 0.6 + 0.4*Math.sin(2*Math.PI*freq*t);
          const env = 0.45 + 0.55*Math.sin(t*Math.PI);
          amps[i] = Math.max(0, ampMax * env * vib);

        }else if(modeLocal === 4){
          const spikePos = 0.18 + randRange(-0.05,0.05);
          const decay = Math.exp(-6.0*Math.max(0, t-spikePos));
          const spike = Math.exp(-((t-spikePos)*(t-spikePos))/(2*0.0015));
          const a = (0.25*ampMax) + (2.2*ampMax*spike) + (0.9*ampMax*decay);
          amps[i] = Math.max(0, a);
        }
      }

      drawWaveFilled(xs, amps, yCenter, cat.hex, alpha);
      if(modeLocal === 4) return { stop:true };
      return { stop:false };
    }

    for(let i=0;i<tokens.length;i++){
      const w = weights[i];
      const nm = nextMode(tokensLower, i, mode);

      if(nm !== mode){
        switches.push({ at: tokens[i], toMode: nm });
        const runW = usableW * (runWeight / totalW);
        const res = drawRun(runTokens, runW, mode);
        xCursor += runW;
        runTokens = [];
        runWeight = 0;
        mode = nm;
        if(res.stop) return { switches };
      }

      runTokens.push(tokens[i]);
      runWeight += w;

      if(mode === 4){
        if(hasNeverAgain(tokensLower,i) && i+1<tokens.length){
          runTokens.push(tokens[i+1]);
          runWeight += weights[i+1];
        }
        const runW = usableW * (runWeight / totalW);
        drawRun(runTokens, runW, mode);
        return { switches };
      }

      if(hasNeverAgain(tokensLower,i)) i++;
    }

    const lastW = usableW * (runWeight / totalW);
    drawRun(runTokens, lastW, mode);
    return { switches };
  }

  // ===== status UI update =====
  const statSentences = document.getElementById("statSentences");
  const statOverall = document.getElementById("statOverall");
  const swOverall = document.getElementById("swOverall");
  const barIntensity = document.getElementById("barIntensity");
  const statIntensity = document.getElementById("statIntensity");
  const statSwitches = document.getElementById("statSwitches");
  const statColors = document.getElementById("statColors");

  function renderChips(list){
    if(!list.length) return "—";
    return list.map(s => `<span class="chip">${s}</span>`).join(" ");
  }

  function draw(text){
    clearCanvas();
    const sentences = splitSentences(text);

    // layout on stage (no lines)
    const staffH = 210;
    const gap = 90;
    const totalH = sentences.length * staffH + (sentences.length-1) * gap;
    let yTop = (canvas.height - totalH) / 2;
    if(yTop < 40) yTop = 40;

    // overall stats from full text
    const allTokens = tokenize(sentences.join(" "));
    const overallCat = pickCategory(allTokens);
    const overallInt = intensityFromTokens(allTokens);

    const usedColors = new Set();
    const allSwitches = [];

    for(const s of sentences){
      const out = drawSentenceWave(s, yTop, staffH, usedColors);
      allSwitches.push(...(out.switches || []));
      yTop += staffH + gap;
    }

    // update status UI
    statSentences.textContent = String(sentences.length);

    swOverall.style.background = overallCat.hex;
    statOverall.textContent = `${LABEL[overallCat.key] || overallCat.key} (${overallCat.hex})`;

    const pct = Math.round((overallInt/10)*100);
    barIntensity.style.width = pct + "%";
    statIntensity.textContent = `${overallInt.toFixed(1)} / 10`;

    const switchText = allSwitches.slice(0, 8).map(s => {
      const name = s.toMode===2 ? "broken" : s.toMode===3 ? "periodic" : s.toMode===4 ? "end" : "basic";
      return `${s.at} → ${name}`;
    });
    statSwitches.innerHTML = renderChips(switchText);

    const colorText = [...usedColors].map(k => `<span class="chip"><span class="sw" style="background:${COLORS[k]}"></span>${LABEL[k] || k}</span>`);
    statColors.innerHTML = colorText.length ? colorText.join(" ") : "—";
  }

  // UI handlers
  const inputEl = document.getElementById("input");
  document.getElementById("btnGen").addEventListener("click", () => draw(inputEl.value));
  document.getElementById("btnRandom").addEventListener("click", () => {
    seed = Math.floor(Math.random()*1e9);
    draw(inputEl.value);
  });

  function downloadPNG(){
    const a=document.createElement("a");
    a.href=canvas.toDataURL("image/png");
    a.download="emotion-waveform.png";
    a.click();
  }
  document.getElementById("btnDownload").addEventListener("click", downloadPNG);
  document.getElementById("btnSaveTop").addEventListener("click", downloadPNG);
  document.getElementById("btnSaveBottom").addEventListener("click", downloadPNG);

  // initial render
  draw(inputEl.value);
})();
</script>
</body>
</html>
