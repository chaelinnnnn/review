<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Emotion Waveform</title>
<style>
  :root{
    --bg:#c7c7a6;            /* khaki/olive paper */
    --panel:#e7e7d6;         /* light panel */
    --panel2:#dedecb;        /* slightly darker panel */
    --ink:#2b2b22;           /* dark olive text */
    --muted:rgba(43,43,34,.55);
    --line:rgba(43,43,34,.18);
    --shadow:rgba(0,0,0,.08);
  }

  *{ box-sizing:border-box; }
  body{
    margin:0;
    background:var(--bg);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
    color:var(--ink);
  }

  /* Layout: left UI column + right canvas */
  .app{
    display:grid;
    grid-template-columns: 420px 1fr;
    min-height:100vh;
    gap:24px;
    padding:28px;
  }

  /* UI chrome */
  .ui{
    position:sticky;
    top:20px;
    align-self:start;
  }

  .tabs{
    display:flex;
    gap:10px;
    align-items:center;
    margin-bottom:14px;
  }

  .tab{
    background:var(--panel2);
    border:1px solid var(--line);
    padding:10px 14px;
    font-size:12px;
    letter-spacing:.08em;
    text-transform:uppercase;
    box-shadow: 0 1px 0 var(--shadow);
    user-select:none;
  }
  .tab.active{
    background:var(--panel);
  }

  .btn-save{
    margin-left:auto;
    background:var(--panel);
    border:1px solid var(--line);
    padding:10px 14px;
    font-size:12px;
    letter-spacing:.08em;
    text-transform:uppercase;
    cursor:pointer;
    box-shadow: 0 1px 0 var(--shadow);
  }
  .btn-save:hover{ filter:brightness(0.98); }

  .panel{
    background:var(--panel);
    border:1px solid var(--line);
    box-shadow: 0 2px 0 var(--shadow);
    padding:14px;
    margin-bottom:16px;
  }

  .panel h3{
    margin:0 0 10px 0;
    font-size:12px;
    letter-spacing:.08em;
    text-transform:uppercase;
    color:var(--muted);
  }

  .grid2{
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap:12px;
  }

  .label{
    font-size:11px;
    letter-spacing:.06em;
    text-transform:uppercase;
    color:var(--muted);
    margin-bottom:6px;
  }

  .fake-select{
    height:34px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    padding:0 10px;
    background:var(--panel2);
    border:1px solid var(--line);
    font-size:12px;
    color:var(--ink);
    user-select:none;
  }
  .caret{
    width:0;height:0;
    border-left:5px solid transparent;
    border-right:5px solid transparent;
    border-top:6px solid var(--muted);
    opacity:.9;
  }

  .fake-slider{
    position:relative;
    height:8px;
    background:rgba(43,43,34,.12);
    border:1px solid var(--line);
    margin-top:8px;
  }
  .fake-slider::after{
    content:"";
    position:absolute;
    left:22%;
    top:-5px;
    width:0;height:0;
    border-left:6px solid transparent;
    border-right:6px solid transparent;
    border-top:10px solid #f7399d; /* accent triangle like ref */
    filter:drop-shadow(0 1px 0 rgba(0,0,0,.08));
  }

  textarea{
    width:100%;
    height:130px;
    resize:none;
    padding:10px;
    font-size:13px;
    line-height:1.45;
    color:var(--ink);
    background:var(--panel2);
    border:1px solid var(--line);
    outline:none;
  }

  .actions{
    display:flex;
    gap:10px;
    margin-top:10px;
  }
  .btn{
    flex:1;
    background:var(--panel);
    border:1px solid var(--line);
    padding:10px 12px;
    font-size:12px;
    letter-spacing:.06em;
    text-transform:uppercase;
    cursor:pointer;
    box-shadow: 0 1px 0 var(--shadow);
  }
  .btn:hover{ filter:brightness(0.985); }

  /* Right: canvas stage */
  .stage{
    background:transparent;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:18px 0;
  }
  canvas{
    width:100%;
    max-width:1400px;
    background:transparent; /* keep paper bg */
  }

  /* Small caption line (optional) */
  .note{
    font-size:12px;
    color:var(--muted);
    margin-top:8px;
  }

  @media (max-width: 980px){
    .app{ grid-template-columns: 1fr; }
    .ui{ position:relative; top:auto; }
  }
</style>
</head>
<body>

<div class="app">
  <!-- LEFT UI (graphic-style, mostly non-functional controls) -->
  <div class="ui">
    <div class="tabs">
      <div class="tab active">Layering</div>
      <div class="tab">Animation</div>
      <button class="btn-save" id="btnSaveTop">Save</button>
    </div>

    <div class="panel">
      <h3>Layer 1</h3>
      <div class="grid2">
        <div>
          <div class="label">Particle set</div>
          <div class="fake-select">WAVEFORM <span class="caret"></span></div>
        </div>
        <div>
          <div class="label">Color set</div>
          <div class="fake-select">EMOTION HEX <span class="caret"></span></div>
        </div>
      </div>
      <div style="margin-top:12px;">
        <div class="label">Size</div>
        <div class="fake-slider"></div>
      </div>
    </div>

    <div class="panel">
      <h3>Layer 2</h3>
      <div class="grid2">
        <div>
          <div class="label">Particle set</div>
          <div class="fake-select">SEGMENTS <span class="caret"></span></div>
        </div>
        <div>
          <div class="label">Color</div>
          <div class="fake-select">AUTO <span class="caret"></span></div>
        </div>
      </div>
      <div style="margin-top:12px;">
        <div class="label">Size</div>
        <div class="fake-slider"></div>
      </div>
    </div>

    <div class="panel">
      <h3>Layer 3</h3>
      <div class="grid2">
        <div>
          <div class="label">Particle set</div>
          <div class="fake-select">SPIKES <span class="caret"></span></div>
        </div>
        <div>
          <div class="label">Color</div>
          <div class="fake-select">ACCENT <span class="caret"></span></div>
        </div>
      </div>
      <div style="margin-top:12px;">
        <div class="label">Size</div>
        <div class="fake-slider"></div>
      </div>
    </div>

    <div class="panel">
      <h3>Input</h3>
      <textarea id="input">I love this app but it crashes now. Never again, I'm done.</textarea>
      <div class="actions">
        <button class="btn" id="btnGen">Generate</button>
        <button class="btn" id="btnRandom">Randomize</button>
      </div>
      <div class="note">* UI는 레퍼런스처럼 보이도록 만든 “그래픽 크롬”이며, 실제 컨트롤은 입력/생성/저장만 동작합니다.</div>
    </div>

    <div class="panel">
      <h3>Export</h3>
      <div class="actions">
        <button class="btn" id="btnDownload">Download PNG</button>
        <button class="btn" id="btnSaveBottom">Save</button>
      </div>
      <div class="note">PNG로 저장 후 인쇄용 편집툴에서 배치하면 좋아요.</div>
    </div>
  </div>

  <!-- RIGHT STAGE -->
  <div class="stage">
    <canvas id="c" width="1800" height="900"></canvas>
  </div>
</div>

<script>
(() => {
  // ===== palette (your hex) =====
  const COLORS = {
    basic_pos:"#00FF90",
    strong_pos:"#DFFF29",
    attach_pos:"#FF6134",
    extreme_pos:"#F7399D",
    mild_neg:"#00FFFF",
    strong_neg:"#006AA0",
    extreme_neg:"#020605"
  };

  // ===== minimal keyword starter for coloring =====
  const KW = {
    attach_pos:new Set(["love","loved","loving","favorite","favourite","obsessed","addicted"]),
    strong_pos:new Set(["great","amazing","excellent","fantastic"]),
    basic_pos:new Set(["good","nice","helpful","useful","easy","works"]),
    mild_neg:new Set(["slow","buggy","glitch","glitchy","annoying","crash","crashes","freeze","freezes"]),
    strong_neg:new Set(["bad","terrible","broken","unacceptable"]),
    extreme_neg:new Set(["worst","scam","delete","uninstall","done","never","again","fraud"])
  };

  const TRIG = {
    contrast: new Set(["but","however","though","although","yet"]),
    time: new Set(["now","still","again","anymore","since","lately","recently","already"]),
    break: new Set(["delete","uninstall","bye","done"]),
  };

  // pitch (0..1) higher -> upper
  const BASE_PITCH = {
    basic_pos: 0.44,
    strong_pos: 0.58,
    attach_pos: 0.70,
    extreme_pos: 0.86,
    mild_neg: 0.36,
    strong_neg: 0.55,
    extreme_neg: 0.22
  };

  // sentence splitting
  function splitSentences(text){
    return (text||"")
      .split(/[\n\r]+|(?<=[.!?])\s+/g)
      .map(s=>s.trim())
      .filter(Boolean);
  }
  function tokenize(sentence){
    return sentence.trim().split(/\s+/g)
      .map(t=>t.replace(/[^\w'\/-]/g,""))
      .filter(Boolean);
  }
  function hasNeverAgain(tokensLower,i){
    return tokensLower[i]==="never" && tokensLower[i+1]==="again";
  }

  // RNG
  let seed = 1234567;
  function rand(){
    seed = (seed*1664525 + 1013904223) % 4294967296;
    return seed/4294967296;
  }
  function randRange(a,b){ return a + (b-a)*rand(); }

  function scoreHits(tokens){
    const hits = {
      basic_pos:0,strong_pos:0,attach_pos:0,extreme_pos:0,
      mild_neg:0,strong_neg:0,extreme_neg:0
    };
    for(const raw of tokens){
      const t = raw.toLowerCase();
      for(const k in KW){
        if(KW[k].has(t)) hits[k] += 1;
      }
      if(t==="10/10") hits.extreme_pos += 2;
    }
    return hits;
  }

  function pickCategory(tokens){
    const hits = scoreHits(tokens);
    let best="basic_pos", bestV=-1;
    for(const k in hits){
      if(hits[k] > bestV){ bestV = hits[k]; best = k; }
    }
    if(bestV<=0) return {key:"basic_pos", hex:COLORS.basic_pos, hitCount:0};
    return {key:best, hex:COLORS[best], hitCount:bestV};
  }

  function intensityFromTokens(tokens){
    const hits = scoreHits(tokens);
    const sumHits = Object.values(hits).reduce((a,b)=>a+b,0);
    const lenBoost = Math.min(3, Math.floor(tokens.length/6));
    const base = sumHits*2 + lenBoost;
    return Math.max(0, Math.min(10, base));
  }

  function ampFromIntensity(intensity, staffH){
    return 8 + (intensity/10) * (staffH * 0.36);
  }

  function alphaFromIntensity(intensity){
    return Math.min(0.92, 0.20 + (intensity/10) * 0.70);
  }

  function nextMode(tokensLower,i,cur){
    if(hasNeverAgain(tokensLower,i)) return 4;
    const t = tokensLower[i];
    if(TRIG.break.has(t)) return 4;
    if(TRIG.time.has(t)) return 3;
    if(TRIG.contrast.has(t)) return 2;
    return cur;
  }

  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  function clearCanvas(){
    // transparent so body bg shows through
    ctx.clearRect(0,0,canvas.width,canvas.height);
  }

  function yFromPitch(pitch01, yTop, staffH){
    return yTop + (1 - pitch01) * staffH;
  }

  // filled waveform
  function drawWaveFilled(xs, amps, yCenter, colorHex, alpha){
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = colorHex;

    ctx.beginPath();
    ctx.moveTo(xs[0], yCenter - amps[0]);
    for(let i=1;i<xs.length;i++) ctx.lineTo(xs[i], yCenter - amps[i]);
    for(let i=xs.length-1;i>=0;i--) ctx.lineTo(xs[i], yCenter + amps[i]);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  function drawSentenceWave(sentence, yTop, staffH){
    const tokens = tokenize(sentence);
    const tokensLower = tokens.map(t=>t.toLowerCase());
    if(!tokens.length) return;

    const overallCat = pickCategory(tokens);
    const overallIntensity = intensityFromTokens(tokens);

    let pitch = (BASE_PITCH[overallCat.key] ?? 0.52) + randRange(-0.02, 0.02);
    pitch = Math.max(0.06, Math.min(0.94, pitch));
    const yCenter = yFromPitch(pitch, yTop, staffH);

    const xStart = 120;
    const xEnd = canvas.width - 120;
    const usableW = xEnd - xStart;

    const weights = tokens.map(t=>Math.max(1.0, Math.min(10, t.length/3)));
    const totalW = weights.reduce((a,b)=>a+b,0);

    let mode = 1;
    let runTokens = [];
    let runWeight = 0;
    let xCursor = xStart;

    function drawRun(runTokensLocal, runW, modeLocal){
      if(!runTokensLocal.length || runW <= 2) return { stop:false };

      const cat = pickCategory(runTokensLocal);
      const inten = intensityFromTokens(runTokensLocal);
      const ampMax = ampFromIntensity(inten, staffH);
      const alpha = alphaFromIntensity(inten);

      const N = Math.max(160, Math.floor(runW/3));
      const xs = new Array(N);
      const amps = new Array(N);

      for(let i=0;i<N;i++){
        const t = i/(N-1);
        xs[i] = xCursor + t * runW;

        if(modeLocal === 1){
          const noise = (rand()-0.5)*0.55;
          const env = 0.55 + 0.45*Math.sin(t*Math.PI);
          amps[i] = Math.max(0, ampMax * env * (0.55 + noise));

        }else if(modeLocal === 2){
          const dropout = (rand() < 0.07) ? 0.0 : 1.0;
          const noise = (rand()-0.5)*1.25;
          const env = 0.35 + 0.65*Math.sin(t*Math.PI);
          amps[i] = Math.max(0, ampMax * env * Math.max(0, 0.65 + noise) * dropout);

        }else if(modeLocal === 3){
          const freq = randRange(10,18);
          const vib = 0.6 + 0.4*Math.sin(2*Math.PI*freq*t);
          const env = 0.45 + 0.55*Math.sin(t*Math.PI);
          amps[i] = Math.max(0, ampMax * env * vib);

        }else if(modeLocal === 4){
          const spikePos = 0.18 + randRange(-0.05,0.05);
          const decay = Math.exp(-6.0*Math.max(0, t-spikePos));
          const spike = Math.exp(-((t-spikePos)*(t-spikePos))/(2*0.0015));
          const a = (0.25*ampMax) + (2.2*ampMax*spike) + (0.9*ampMax*decay);
          amps[i] = Math.max(0, a);
        }
      }

      drawWaveFilled(xs, amps, yCenter, cat.hex, alpha);
      if(modeLocal === 4) return { stop:true };
      return { stop:false };
    }

    for(let i=0;i<tokens.length;i++){
      const w = weights[i];
      const nm = nextMode(tokensLower, i, mode);

      if(nm !== mode){
        const runW = usableW * (runWeight / totalW);
        const res = drawRun(runTokens, runW, mode);
        xCursor += runW;
        runTokens = [];
        runWeight = 0;
        mode = nm;
        if(res.stop) return;
      }

      runTokens.push(tokens[i]);
      runWeight += w;

      if(mode === 4){
        if(hasNeverAgain(tokensLower,i) && i+1<tokens.length){
          runTokens.push(tokens[i+1]);
          runWeight += weights[i+1];
        }
        const runW = usableW * (runWeight / totalW);
        drawRun(runTokens, runW, mode);
        return;
      }

      if(hasNeverAgain(tokensLower,i)) i++;
    }

    const lastW = usableW * (runWeight / totalW);
    drawRun(runTokens, lastW, mode);
  }

  function draw(text){
    clearCanvas();
    const sentences = splitSentences(text);

    // Stage layout (no lines/labels)
    const staffH = 210;
    const gap = 90;

    // center vertically
    const totalH = sentences.length * staffH + (sentences.length-1)*gap;
    let yTop = (canvas.height - totalH)/2;
    if(yTop < 30) yTop = 30;

    for(let s=0;s<sentences.length;s++){
      drawSentenceWave(sentences[s], yTop, staffH);
      yTop += staffH + gap;
    }
  }

  // UI handlers
  const inputEl = document.getElementById("input");
  document.getElementById("btnGen").addEventListener("click", () => draw(inputEl.value));
  document.getElementById("btnRandom").addEventListener("click", () => { seed = Math.floor(Math.random()*1e9); draw(inputEl.value); });

  function downloadPNG(){
    const a=document.createElement("a");
    a.href=canvas.toDataURL("image/png");
    a.download="emotion-waveform.png";
    a.click();
  }
  document.getElementById("btnDownload").addEventListener("click", downloadPNG);

  // "Save" buttons are stylistic; map to download for now
  document.getElementById("btnSaveTop").addEventListener("click", downloadPNG);
  document.getElementById("btnSaveBottom").addEventListener("click", downloadPNG);

  // initial render
  draw(inputEl.value);
})();
</script>
</body>
</html>
